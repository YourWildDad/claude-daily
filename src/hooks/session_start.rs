use anyhow::Result;
use chrono::{Local, Timelike};
use std::fs;
use std::process::{Command, Stdio};

use crate::archive::ArchiveManager;
use crate::config::load_config;
use crate::hooks::read_hook_input;

/// Handle SessionStart hook from Claude Code
/// Creates today's directory if it doesn't exist and initializes daily.md
pub async fn handle() -> Result<()> {
    let config = load_config()?;

    // Check if hooks are enabled
    if !config.hooks.enable_session_start {
        return Ok(());
    }

    // Try to read hook input, but don't fail if not available
    // (allows manual testing without stdin)
    let _input = match read_hook_input() {
        Ok(input) => Some(input),
        Err(_) => None,
    };

    let today = Local::now().format("%Y-%m-%d").to_string();
    let daily_dir = config.today_dir();

    // Create today's directory if first session of the day
    if !daily_dir.exists() {
        fs::create_dir_all(&daily_dir)?;

        // Initialize daily.md with frontmatter
        let daily_md = daily_dir.join("daily.md");
        let now = Local::now();
        let content = format!(
            r#"---
date: {}
created: {}
updated: {}
tags: [daily-summary, claude-code]
sessions: []
total_sessions: 0
---

# Daily Summary - {}

## Overview

_No sessions archived yet._

## Sessions

## Key Insights

## Skills & Commands Identified

## Reflections

---
*Generated by Daily Context Archive System*
"#,
            today,
            now.to_rfc3339(),
            now.to_rfc3339(),
            today
        );
        fs::write(&daily_md, content)?;

        eprintln!("[daily] Created daily directory: {}", daily_dir.display());
    }

    // Check for auto-digest of previous day's sessions
    if config.summarization.auto_digest_enabled {
        check_auto_digest(&config);
    }

    // Exit with 0 to allow session to continue
    Ok(())
}

/// Check if we should auto-digest yesterday's sessions
fn check_auto_digest(config: &crate::config::Config) {
    // Parse digest_time (format: "HH:MM")
    let digest_time = &config.summarization.digest_time;
    let parts: Vec<&str> = digest_time.split(':').collect();
    if parts.len() != 2 {
        return;
    }

    let (digest_hour, digest_minute) = match (parts[0].parse::<u32>(), parts[1].parse::<u32>()) {
        (Ok(h), Ok(m)) if h < 24 && m < 60 => (h, m),
        _ => return,
    };

    let now = Local::now();
    let current_minutes = now.hour() * 60 + now.minute();
    let digest_minutes = digest_hour * 60 + digest_minute;

    // Only trigger if we're past digest time
    if current_minutes < digest_minutes {
        return;
    }

    // Get yesterday's date
    let yesterday = (now - chrono::Duration::days(1))
        .format("%Y-%m-%d")
        .to_string();

    // Check if yesterday has un-digested sessions
    let manager = ArchiveManager::new(config.clone());
    if !manager.has_sessions(&yesterday) {
        return;
    }

    eprintln!(
        "[daily] Auto-digesting yesterday's sessions ({})...",
        yesterday
    );

    // Spawn background digest process
    if let Ok(exe) = std::env::current_exe() {
        let _ = Command::new(&exe)
            .args(["digest", "--date", &yesterday, "--foreground"])
            .stdin(Stdio::null())
            .stdout(Stdio::null())
            .stderr(Stdio::null())
            .spawn();
    }
}
